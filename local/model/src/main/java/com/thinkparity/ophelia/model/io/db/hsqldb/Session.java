/*
 * Feb 9, 2006
 */
package com.thinkparity.ophelia.model.io.db.hsqldb;

import java.io.InputStream;
import java.sql.*;
import java.util.Calendar;
import java.util.UUID;

import com.thinkparity.codebase.DateUtil;
import com.thinkparity.codebase.JVMUniqueId;
import com.thinkparity.codebase.email.EMail;
import com.thinkparity.codebase.email.EMailBuilder;
import com.thinkparity.codebase.email.EMailFormatException;
import com.thinkparity.codebase.jabber.JabberId;
import com.thinkparity.codebase.jabber.JabberIdBuilder;
import com.thinkparity.codebase.log4j.Log4JWrapper;
import com.thinkparity.codebase.model.artifact.ArtifactFlag;
import com.thinkparity.codebase.model.artifact.ArtifactState;
import com.thinkparity.codebase.model.artifact.ArtifactType;
import com.thinkparity.codebase.model.migrator.Library;

import com.thinkparity.ophelia.model.audit.AuditEventType;
import com.thinkparity.ophelia.model.container.ContainerDraft;
import com.thinkparity.ophelia.model.io.md.MetaData;
import com.thinkparity.ophelia.model.io.md.MetaDataType;
import com.thinkparity.ophelia.model.message.SystemMessageType;

/**
 * @author raykroeker@gmail.com
 * @version 1.1
 */
public class Session {

    /** An apache logger. */
	protected final Log4JWrapper logger;

    /** The sql connection. */
	private final Connection connection;

	/** The session id. */
	private final JVMUniqueId id;

    /** The connection meta data. */
    private DatabaseMetaData metaData;

    /** The session's prepared statement. */
	private PreparedStatement preparedStatement;

    /** The prepared statement's result set. */
	private ResultSet resultSet;

	/** The <code>SessionManager</code>. */
    private final SessionManager sessionManager;

    /**
     * Create a Session.
     * 
     * @param sessionManager
     *            The <code>SessionManager</code>.
     * @param connection
     *            The sql <code>Connection</code>.
     */
	Session(final SessionManager sessionManager, final Connection connection) {
		super();
		this.connection = connection;
		this.logger = new Log4JWrapper();
		this.id = JVMUniqueId.nextId();
        this.sessionManager = sessionManager;
	}

	public void close() {
		assertOpen("Cannot close a closed session.");
		try {
			close(preparedStatement, resultSet);
			connection.close();
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		sessionManager.close(this);
	}

	public void commit() {
		assertOpen("commit()");
		try { connection.commit(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    /**
	 * @see java.lang.Object#equals(java.lang.Object)
	 * 
	 */
	public boolean equals(Object obj) {
		if(null != obj && obj instanceof Session)
			return id.equals(((Session) obj).id);
		return false;
	}

	public void execute(final String sql) {
		assertOpen("execute(String)");
		logger.logVariable("sql", sql);
		try {
			final Statement s = connection.createStatement();
			s.execute(sql);
			commit();
		}
		catch(final SQLException sqlx) {
			rollback();
			throw new HypersonicException(sqlx);
		}
	}

	public void execute(final String[] sql) {
		assertOpen("execute(String[]");
		logger.logVariable("sql", sql);
		Statement statement = null;
		try {
			statement = connection.createStatement();
			for(final String s : sql) {
				statement.addBatch(s);
			}
			statement.executeBatch();
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		finally { close(statement); }
	}

	/**
	 * Executes the SQL query in the session <code>PreparedStatement</code>
	 * object and sets the <code>ResultSet</code> object generated by the
	 * query.
	 * 
	 * @see #prepareStatement(String)
	 * @see #nextResult()
	 */
	public void executeQuery() {
		assertOpen("Cannot execute query if the session is not open.");
		assertPreparedStatement("Cannot execute query if the statement is not prepared.");
		try { resultSet = preparedStatement.executeQuery(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public int executeUpdate() {
		assertOpen("executeUpdate()");
		assertPreparedStatement("executeUpdate()");
		try { return preparedStatement.executeUpdate(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public AuditEventType getAuditEventTypeFromInteger(final String columnName) {
		assertOpen("getAuditEventTypeFromInteger(String)");
		assertOpenResult("getAuditEventTypeFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : AuditEventType.fromId(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

    public Boolean getBoolean(final String columnName) {
        assertOpen("[GET BOOLEAN]");
        assertOpenResult("[GET BOOLEAN]");
        logger.logVariable("columnName", columnName);
        try {
            final Boolean value = resultSet.getBoolean(columnName);
            return resultSet.wasNull() ? null : value;
        }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public byte[] getBytes(final String columnName) {
		assertOpen("getBytes(String)");
		assertOpenResult("getBytes(String)");
		try {
            final byte[] value = resultSet.getBytes(columnName);
            return resultSet.wasNull() ? null : value;
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

    public Calendar getCalendar(final String columnName) {
		assertOpen("getCalendar(String)");
		assertOpenResult("getCalendar(String)");
		try {
			final Calendar calendar = DateUtil.getInstance();
			final Timestamp timestamp = resultSet.getTimestamp(columnName, calendar);
			if (resultSet.wasNull()) { return null; }
			else {
				calendar.setTime(timestamp);
				return calendar;
			}
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

    public ContainerDraft.ArtifactState getContainerStateFromString(
            final String columnName) {
        assertOpen("getStateFromString(String)");
        assertOpenResult("getStateFromString(String)");
        logger.logVariable("columnName", columnName);
        try {
            final String value = resultSet.getString(columnName);
            return resultSet.wasNull() ? null : ContainerDraft.ArtifactState.valueOf(value);
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

    public EMail getEMail(final String columnName) {
        assertOpen("getCalendar(String)");
        assertOpenResult("getCalendar(String)");
        try {
            final String value = resultSet.getString(columnName);
            if (resultSet.wasNull()) { return null; }
            else {
                return EMailBuilder.parse(value);
            }
        } catch (final EMailFormatException efx) {
            throw new HypersonicException(efx);
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

	public ArtifactFlag getFlagFromInteger(final String columnName) {
		assertOpen("getFlagFromInteger(String)");
		assertOpenResult("getFlagFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : ArtifactFlag.fromId(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public ArtifactFlag getFlagFromString(final String columnName) {
		assertOpen("getFlagFromString(String)");
		assertOpenResult("getFlagFromString(String)");
		logger.logVariable("columnName", columnName);
		try {
            final String value = resultSet.getString(columnName);
            return resultSet.wasNull() ? null : ArtifactFlag.valueOf(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	/**
	 * Obtain the session id.
	 * 
	 * @return The session id.
	 */
	public JVMUniqueId getId() { return id; }

	/**
     * Execute a query to obtain the identity created.
     * 
     * @return The identity value.
     */
	public Long getIdentity() {
		ResultSet resultSet = null;
		try {
			resultSet = list("CALL IDENTITY()");
			resultSet.next();
			return resultSet.getLong(1);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
		finally { close(resultSet); }
	}

	/**
     * Obtain the input stream from the result.
     * 
     * @param columnName
     *            The column name.
     * @return An input stream.
     * @see ResultSet#getBinaryStream(String)
     */
    public InputStream getInputStream(final String columnName) {
        assertOpen("[GET INPUT STREAM]");
        assertOpenResult("[GET INPUT STREAM]");
        logger.logVariable("columnName", columnName);
        try {
            final InputStream value = resultSet.getBinaryStream(columnName);
            return resultSet.wasNull() ? null : value;
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

    public Integer getInteger(final String columnName) {
        assertOpen("[LMODEL] [IO] [HSQL] [GET INTEGER]");
        assertOpenResult("[LMODEL] [IO] [HSQL] [GET INTEGER]");
        logger.logVariable("columnName", columnName);
        try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : value;
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

    public Long getLong(final String columnName) {
		assertOpen("getLong(String)");
		assertOpenResult("getLong(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Long value = resultSet.getLong(columnName);
            return resultSet.wasNull() ? null : value;
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
	}

	public void getMetaDataTables() {
        assertOpen();
        assertMetaData();
        try {
            resultSet = metaData.getTables(null, "PUBLIC", null, new String[] {"TABLE"});
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

	public MetaDataType getMetaDataTypeFromInteger(final String columnName) {
		assertOpen("getMetaDataTypeFromInteger(String)");
		assertOpenResult("getMetaDataTypeFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : MetaDataType.fromId(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public JabberId getQualifiedUsername(final String columnName) {
		assertOpen("Cannot get values if the session is not open.");
		assertOpenResult("Cannot get values if the result is not open.");
		logger.logVariable("columnName", columnName);
		try {
			final String value = resultSet.getString(columnName);
			if (resultSet.wasNull()) {
                return null;
			} else {
                return JabberIdBuilder.parseQualifiedUsername(value);
			}
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		} catch (final IllegalArgumentException iax) {
            throw new HypersonicException(iax);
		}
	}

	public ArtifactState getStateFromInteger(final String columnName) {
		assertOpen("getStateFromInteger(String)");
		assertOpenResult("getStateFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : ArtifactState.fromId(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public ArtifactState getStateFromString(final String columnName) {
		assertOpen("getStateFromString(String)");
		assertOpenResult("getStateFromString(String)");
		logger.logVariable("columnName", columnName);
		try {
            final String value = resultSet.getString(columnName);
            return resultSet.wasNull() ? null : ArtifactState.valueOf(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public String getString(final String columnName) {
		assertOpen("getString(String)");
		assertOpenResult("getString(String)");
		logger.logVariable("columnName", columnName);
		try {
            final String value = resultSet.getString(columnName);
            return resultSet.wasNull() ? null : value;
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public SystemMessageType getSystemMessageTypeFromInteger(
			final String columnName) {
		assertOpen("getSystemMessageTypeFromInteger(String)");
		assertOpenResult("getSystemMessageTypeFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : SystemMessageType.fromId(value);
		} catch(final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public ArtifactType getTypeFromInteger(final String columnName) {
		assertOpen("getTypeFromInteger(String)");
		assertOpenResult("getTypeFromInteger(String)");
		logger.logVariable("columnName", columnName);
		try {
            final Integer value = resultSet.getInt(columnName);
            return resultSet.wasNull() ? null : ArtifactType.fromId(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public ArtifactType getTypeFromString(final String columnName) {
		assertOpen("getTypeFromString(String)");
		assertOpenResult("getTypeFromString(String)");
		logger.logVariable("columnName", columnName);
		try {
            final String value = resultSet.getString(columnName);
            return resultSet.wasNull() ? null : ArtifactType.valueOf(value);
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public UUID getUniqueId(final String columnName) {
		assertOpen("getString(String)");
		assertOpenResult("getString(String)");
        final String value = getString(columnName);
		return null == value ? null : UUID.fromString(value);
	}

	/**
	 * @see java.lang.Object#hashCode()
	 * 
	 */
	public int hashCode() {
		return id.hashCode();
	}

	public boolean nextResult() {
		assertOpen("nextResult()");
		assertOpenResult("nextResult()");
		try { return resultSet.next(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	/**
	 * Obtain the database metadata.
	 * 
	 * @return The database metadata.
	 * @throws HypersonicException
	 */
	public void openMetaData() {
		assertOpen("getMetaData");
		try {
            metaData = connection.getMetaData();
		} catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
		}
	}

	public PreparedStatement prepareStatement(final String sql) {
		assertOpen("prepareStatement(String)");
		logger.logVariable("sql", sql);
		try {
			preparedStatement = connection.prepareStatement(sql);
			return preparedStatement;
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void rollback() {
		assertOpen("rollbackSession()");
		try { connection.commit(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setBoolean(final Integer index, final Boolean value) {
        assertOpen("setBoolean(Integer,Boolean)");
        assertPreparedStatement("setBoolean(Integer,Boolean)");
        logIndexAndValue(index, value);
        try { preparedStatement.setBoolean(index, value); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setBytes(final Integer index, final byte[] value) {
		assertOpen("setBytes(Integer,Byte[])");
		assertPreparedStatement("setBytes(Integer,Byte[])");
        logIndexAndValue(index, value);
		try { preparedStatement.setBytes(index, value); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setCalendar(final Integer index, final Calendar value) {
		assertOpen("setCalendar(Integer,Calendar)");
		assertPreparedStatement("setCalendar(Integer,Calendar)");
        logIndexAndValue(index, value);
		try {
			preparedStatement.setTimestamp(index,
					new Timestamp(value.getTimeInMillis()), value);
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setEMail(final Integer index, final EMail value) {
        assertOpen("setEMail(Integer,EMail)");
        assertPreparedStatement("setEMail(Integer,EMail)");
        logIndexAndValue(index, value);
        try {
            preparedStatement.setString(index, value.toString());
        } catch (final SQLException sqlx) {
            throw new HypersonicException(sqlx);
        }
    }

	public void setEnumTypeAsString(final Integer index, final Enum<?> value) {
        assertOpen("setEnumAsString(Integer,Enum<?>)");
        assertPreparedStatement("setEnumAsString(Integer,Enum<?>)");
        logIndexAndValue(index, value);
        try { preparedStatement.setString(index, value.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public void setFlagAsInteger(final Integer index, final ArtifactFlag value) {
		assertOpen("setFlagAsInteger(Integer,ArtifactFlag)");
		assertPreparedStatement("setFlagAsInteger(Integer,ArtifactFlag)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value.getId()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setFlagAsString(final Integer index, final ArtifactFlag value) {
		assertOpen("setFlagAsString(Integer,ArtifactFlag)");
		assertPreparedStatement("setFlagAsString(Integer,ArtifactFlag)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setInt(final Integer index, final Integer value) {
		assertOpen("setInt(Integer,Integer)");
		assertPreparedStatement("setInt(Integer,Integer)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setLong(final Integer index, final Long value) {
		assertOpen("setLong(Integer,Long)");
		assertPreparedStatement("setLong(Integer,Long)");
        logIndexAndValue(index, value);
		try { preparedStatement.setLong(index, value); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setMetaDataAsString(final Integer index, final MetaData value) {
		assertOpen("setMetaDataAsString(Integer,MetaData)");
		assertPreparedStatement("setMetaDataAsString(Integer,MetaData)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setQualifiedUsername(final Integer index, final JabberId value) {
		assertOpen("Database session is not open.");
		assertPreparedStatement("Prepared statement has not been set.");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.getQualifiedUsername()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setStateAsInteger(final Integer index, final ArtifactState value) {
		assertOpen("setStateAsInteger(Integer,ArtifactState)");
		assertPreparedStatement("setStateAsInteger(Integer,ArtifactState)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value.getId()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setStateAsString(final Integer index, final ArtifactState value) {
        assertOpen("setStateAsString(Integer,ArtifactState)");
        assertPreparedStatement("setStateAsString(Integer,ArtifactState)");
        logIndexAndValue(index, value);
        try { preparedStatement.setString(index, value.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setStateAsString(final Integer index, final ContainerDraft.ArtifactState value) {
        assertOpen("SESSION CONNECTION NOT OPEN");
        assertPreparedStatement("SESSION STATEMENT NOT PREPARED");
        logIndexAndValue(index, value);
        try { preparedStatement.setString(index, value.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setString(final Integer index, final String value) {
		assertOpen("setString(Integer,String)");
		assertPreparedStatement("setString(Integer,String)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsInteger(final Integer index, final ArtifactType value) {
		assertOpen("setTypeAsInteger(Integer,ArtifactType)");
		assertPreparedStatement("setTypeAsInteger(Integer,ArtifactType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value.getId()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setTypeAsInteger(final Integer index, final AuditEventType value) {
		assertOpen("setTypeAsInteger(Integer,AuditEventType)");
		assertPreparedStatement("setTypeAsInteger(Integer,AuditEventType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value.getId()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsInteger(final Integer index, final Library.Type value) {
        assertOpen("setTypeAsInteger(Integer,Library.Type)");
        assertPreparedStatement("setTypeAsInteger(Integer,Library.Type)");
        logIndexAndValue(index, value);
        try { preparedStatement.setInt(index, value.getId()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setTypeAsInteger(final Integer index, final MetaDataType value) {
		assertOpen("setTypeAsInteger(Integer,MetaDataType)");
		assertPreparedStatement("setTypeAsInteger(Integer,MetaDataType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setInt(index, value.getId()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsInteger(final Integer index, final SystemMessageType value) {
        assertOpen("setTypeAsInteger(Integer,SystemMessageType)");
        assertPreparedStatement("setTypeAsInteger(Integer,SystemMessageType)");
        logIndexAndValue(index, value);
        try { preparedStatement.setInt(index, value.getId()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public void setTypeAsString(final Integer index, final ArtifactType value) {
		assertOpen("setTypeAsString(Integer,ArtifactType)");
		assertPreparedStatement("setTypeString(Integer,ArtifactType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setTypeAsString(final Integer index, final AuditEventType value) {
		assertOpen("setTypeAsString(Integer,AuditEventType)");
		assertPreparedStatement("setTypeAsString(Integer,AuditEventType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsString(final Integer index, final Enum<?> value) {
		assertOpen("setTypeAsString(Integer,Enum<?>)");
		assertPreparedStatement("setTypeString(Integer,Enum<?>)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsString(final Integer index, final Library.Type value) {
        assertOpen("setType(Integer,Library.Type)");
        assertPreparedStatement("setTypeString(Integer,Library.Type)");
        logIndexAndValue(index, value);
        try { preparedStatement.setString(index, value.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public void setTypeAsString(final Integer index, final MetaDataType value) {
		assertOpen("setType(Integer,MetaDataType)");
		assertPreparedStatement("setTypeString(Integer,MetaDataType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setTypeAsString(final Integer index, final SystemMessageType value) {
		assertOpen("setTypeAsString(Integer,SystemMessageType)");
		assertPreparedStatement("setTypeAsString(Integer,SystemMessageType)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setUniqueId(final Integer index, final UUID value) {
		assertOpen("setUniqueId(Integer,UUID)");
		assertPreparedStatement("setUniqueId(Integer,UUID)");
        logIndexAndValue(index, value);
		try { preparedStatement.setString(index, value.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void assertMetaData() {
        if (null == metaData)
            throw new HypersonicException("META-DATA IS NULL");
    }

    private void assertOpen() {
        assertOpen("CONNECTION IS NULL");
    }

	private void assertOpen(final String caller) {
		if(null == connection) {
			throw new HypersonicException("Session is closed:  " + caller);
		}
	}

	private void assertOpenResult(final String caller) {
		if(null == resultSet)
			throw new HypersonicException("Result is closed:  " + caller);
	}

    private void assertPreparedStatement(final String caller) {
		if(null == preparedStatement)
			throw new HypersonicException("Prepared statement is null:  " + caller);
	}

	private void close(final ResultSet resultSet) {
		try { if(null != resultSet) resultSet.close(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void close(final Statement statement) {
		try { if(null != statement) statement.close(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void close(final Statement statement, final ResultSet resultSet) {
		close(statement);
		close(resultSet);
	}

	private ResultSet list(final String sql) {
		assertOpen("list(String)");
		logger.logVariable("sql", sql);
		Statement statement = null;
		try {
			statement = connection.createStatement();
			return statement.executeQuery(sql);
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		finally { close(statement); }
	}

    /**
     * Log the index and it's value.
     * 
     * @param index
     *            A prepared statement index.
     * @param value
     *            The prepared statement's index value.
     */
    private void logIndexAndValue(final Integer index, final Object value) {
        logger.logDebug("sql:{0}={1}", index, value);
    }
}
