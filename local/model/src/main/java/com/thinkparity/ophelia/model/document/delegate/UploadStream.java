/*
 * Created On:  21-Jul-07 2:14:47 PM
 */
package com.thinkparity.ophelia.model.document.delegate;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.text.MessageFormat;

import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

import com.thinkparity.codebase.assertion.Assert;
import com.thinkparity.codebase.crypto.CryptoMonitor;
import com.thinkparity.codebase.crypto.EncryptStream;
import com.thinkparity.codebase.io.StreamOpener;

import com.thinkparity.codebase.model.crypto.Secret;
import com.thinkparity.codebase.model.document.DocumentVersion;
import com.thinkparity.codebase.model.stream.StreamInfo;
import com.thinkparity.codebase.model.stream.StreamSession;


import com.thinkparity.ophelia.model.container.monitor.PublishData;
import com.thinkparity.ophelia.model.container.monitor.PublishStep;
import com.thinkparity.ophelia.model.crypto.InternalCryptoModel;
import com.thinkparity.ophelia.model.document.DocumentDelegate;
import com.thinkparity.ophelia.model.session.OfflineException;
import com.thinkparity.ophelia.model.util.ProcessMonitor;

import com.thinkparity.net.NetworkException;
import com.thinkparity.stream.StreamMonitor;
import com.thinkparity.stream.upload.UploadFile;


/**
 * <b>Title:</b>thinkParity Ophelia Model Document Upload Stream Delegate<br>
 * <b>Description:</b>An implementation of the upload stream api<br>
 * 
 * @author raymond@thinkparity.com
 * @version 1.1.2.1
 */
public final class UploadStream extends DocumentDelegate {

    /** The process monitor. */
    private ProcessMonitor monitor;

    /** The document name. */
    private String name;

    /** An upload completion indicator. */
    private Boolean uploadComplete;

    /** An error generated by the upload delegate. */
    private Throwable uploadDelegateError;

    /** The document version. */
    private DocumentVersion version;

    /**
     * Create UploadStream.
     *
     */
    public UploadStream() {
        super();
    }

    /**
     * Set the stream monitor.
     * 
     * @param monitor
     *            A <code>ProcessMonitor</code>.
     */
    public void setMonitor(final ProcessMonitor monitor) {
        this.monitor = monitor;
    }

    /**
     * Set the version.
     * 
     * @param version
     *            A <code>DocumentVersion</code>.
     */
    public void setVersion(final DocumentVersion version) {
        this.name = version.getArtifactName();
        this.version = version;
    }

    /**
     * Upload a document version to the streaming server.
     * 
     * @throws NetworkException
     * @throws IOException
     */
    public void uploadStream() throws NetworkException, IOException {
        final File encrypted = createTempFile(name);
        try {
            encrypt(resolveSecret(), encrypted);
            upload(encrypted);
        } finally {
            // TEMPFILE - UploadStream#uploadStream()
            encrypted.delete();
        }
    }

    /**
     * Encrypt the document version content.
     * 
     * @param secret
     *            A <code>Secret</code>.
     * @param target
     *            A <code>File</code>.
     * @throws IOException
     * @throws NoSuchPaddingException
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeyException
     */
    private void encrypt(final Secret secret, final File target)
            throws IOException {
        final Key key = new SecretKeySpec(secret.getKey(), secret.getAlgorithm());
        documentIO.openStream(version.getArtifactId(), version.getVersionId(), new StreamOpener() {
            public void open(final InputStream stream) throws IOException {
                try {
                    final EncryptStream encryptStream = new EncryptStream(
                            newCryptoMonitor(), secret.getAlgorithm());
                    synchronized (getBufferLock()) {
                            encryptStream.encrypt(key, stream, target,
                                    getBufferArray());
                    }
                } catch (final GeneralSecurityException gsx) {
                    throw new IOException(gsx);
                }
            }
        });
    }

    /**
     * Create an abort upload thread name.
     * 
     * @return A <code>String</code>.
     */
    private String newAbortUploadThreadName() {
        return newThreadName("AbortUpload");
    }

    /**
     * Create a crypto monitor. The monitor is responsible for translating
     * encryption progress events into a publish monitor's progress events.
     * 
     * @return A <code>CryptoMonitor</code>.
     */
    private CryptoMonitor newCryptoMonitor() {
        return new CryptoMonitor() {
            /** A publish monitor data. */
            private final PublishData monitorData = new PublishData();
            /**
             * @see com.thinkparity.codebase.crypto.CryptoMonitor#chunkDecrypted(int)
             *
             */
            @Override
            public void chunkDecrypted(final int chunkSize) {
                throw Assert.createUnreachable("Cannot decrypt from here.");
            }
            /**
             * @see com.thinkparity.codebase.crypto.CryptoMonitor#chunkEncrypted(int)
             *
             */
            @Override
            public void chunkEncrypted(final int chunkSize) {
                monitorData.setDocumentVersion(version);
                monitorData.setBytes(chunkSize);
                notifyStepBegin(monitor, PublishStep.ENCRYPT_DOCUMENT_VERSION_BYTES, monitorData);
                notifyStepEnd(monitor, PublishStep.ENCRYPT_DOCUMENT_VERSION_BYTES);
            }
        };
    }

    /**
     * Create a context sensitive thread name.
     * 
     * @param context
     *            A <code>String</code>.
     * @return A <code>String</code>.
     */
    private String newThreadName(final String context) {
        return MessageFormat.format("{0}", context);
    }

    /**
     * Create an upload stream monitor. The stream events are transitioned to
     * events on the process monitor.
     * 
     * @param monitor
     *            A <code>ProcessMonitor</code>.
     * @param streamName
     *            A stream name <code>String</code>.
     * @return A <code>StreamMonitor</code>.
     */
    private StreamMonitor newUploadStreamMonitor(final ProcessMonitor monitor,
            final String streamName) {
        return new StreamMonitor() {
            /** A publish monitor data. */
            private final PublishData monitorData = new PublishData();
            /**
             * @see com.thinkparity.codebase.model.stream.StreamMonitor#chunkReceived(int)
             * 
             */
            @Override
            public void chunkReceived(final int chunkSize) {
                // not possible for upload
                Assert.assertUnreachable("");
            }
            /**
             * @see com.thinkparity.codebase.model.stream.StreamMonitor#chunkSent(int)
             *
             */
            @Override
            public void chunkSent(final int chunkSize) {
                monitorData.setDocumentVersion(version);
                monitorData.setBytes(chunkSize);
                notifyStepBegin(monitor, PublishStep.UPLOAD_DOCUMENT_VERSION_BYTES, monitorData);
                notifyStepEnd(monitor, PublishStep.UPLOAD_DOCUMENT_VERSION_BYTES);
            }
            /**
             * @see com.thinkparity.codebase.model.stream.StreamMonitor#getName()
             *
             */
            @Override
            public String getName() {
                return MessageFormat.format(
                        "UploadStream#newUploadStreamMonitor({0})", streamName);
            }
            /**
             * @see com.thinkparity.codebase.model.stream.StreamMonitor#reset()
             *
             */
            @Override
            public void reset() {
                monitorData.setDocumentVersion(version);
                monitorData.setBytes(0);
                notifyStepBegin(monitor, PublishStep.RESET_UPLOAD_DOCUMENT_VERSION, monitorData);
                notifyStepEnd(monitor, PublishStep.RESET_UPLOAD_DOCUMENT_VERSION);
            }
        };
    }

    /**
     * Create an upload thread name.
     * 
     * @return A <code>String</code>.
     */
    private String newUploadThreadName() {
        return newThreadName("Upload");
    }

    /**
     * Create a new stream session for a version and file.
     * 
     * @param file
     *            A <code>File</code>.
     * @return A <code>StreamSession</code>.
     */
    private StreamSession newUpstreamSession(final File file) throws IOException {
        final StreamInfo streamInfo = new StreamInfo();
        streamInfo.setMD5(checksum(file));
        streamInfo.setSize(Long.valueOf(file.length()));
        return getStreamModel().newUpstreamSession(streamInfo, version);
    }

    /**
     * If the secret for the document version already exists; download it;
     * otherwise create a new secret.
     * 
     * @return A <code>Secret</code>.
     */
    private Secret resolveSecret() {
        final InternalCryptoModel cryptoModel = getCryptoModel();
        if (cryptoModel.doesExistSecret(version)) {
            return cryptoModel.readSecret(version);
        } else {
            return cryptoModel.createSecret(version);
        }
    }

    /**
     * Start a thread to abort the failed upload.
     * 
     * @param delegate
     *            An <code>UploadFile</code>.
     */
    private void startAbort(final UploadFile delegate) {
        final Runnable runnable = new Runnable() {
            /**
             * @see java.lang.Runnable#run()
             *
             */
            @Override
            public void run() {
                try {
                    delegate.abort();
                } catch (final Throwable t) {
                    logger.logError(t, "Could not abort upload.");
                }
            }
        };
        newThread(newAbortUploadThreadName(), runnable).start();
    }

    /**
     * Upload a file.
     * 
     * @param file
     *            A <code>File</code>.
     */
    private void upload(final File file) throws NetworkException, IOException {
        final StreamSession session = newUpstreamSession(file);
        final UploadFile delegate = new UploadFile(
                newUploadStreamMonitor(monitor, file.getName()),
                newDefaultRetryHandler(), session);
        final Runnable runnable = new Runnable() {
            public void run() {
                try {
                    uploadComplete = Boolean.FALSE;
                    delegate.upload(file);
                    uploadComplete = Boolean.TRUE;
                } catch (final Throwable t) {
                    delegate.abort();
                    uploadDelegateError = t;
                } finally {
                    synchronized (this) {
                        this.notify();
                    }
                }
            }
        };
        newThread(newUploadThreadName(), runnable).start();
        while (true) {
            synchronized (runnable) {
                try {
                    runnable.wait(1 * 1000);
                } catch (final InterruptedException ix) {
                    throw panic(ix);
                }
            }
            if (Boolean.TRUE == uploadComplete) {
                break;
            } else if (null != uploadDelegateError) {
                throw panic(uploadDelegateError);
            } else if (Boolean.FALSE == getSessionModel().isOnline()) {
                startAbort(delegate);
                throw new OfflineException();
            }
        }
    }
}
