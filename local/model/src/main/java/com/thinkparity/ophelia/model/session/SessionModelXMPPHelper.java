/*
 * Oct 9, 2005
 */
package com.thinkparity.ophelia.model.session;

import java.io.File;
import java.util.Calendar;
import java.util.List;
import java.util.UUID;

import com.thinkparity.codebase.assertion.Assert;
import com.thinkparity.codebase.email.EMail;
import com.thinkparity.codebase.jabber.JabberId;
import com.thinkparity.codebase.model.artifact.ArtifactType;
import com.thinkparity.codebase.model.profile.Profile;
import com.thinkparity.codebase.model.user.User;


import com.thinkparity.ophelia.model.AbstractModelImplHelper;
import com.thinkparity.ophelia.model.ParityException;
import com.thinkparity.ophelia.model.util.smack.SmackException;
import com.thinkparity.ophelia.model.util.xmpp.XMPPSession;
import com.thinkparity.ophelia.model.util.xmpp.XMPPSessionFactory;
import com.thinkparity.ophelia.model.util.xmpp.events.XMPPArtifactListener;
import com.thinkparity.ophelia.model.util.xmpp.events.XMPPContactListener;
import com.thinkparity.ophelia.model.util.xmpp.events.XMPPContainerListener;
import com.thinkparity.ophelia.model.util.xmpp.events.XMPPDocumentListener;
import com.thinkparity.ophelia.model.util.xmpp.events.XMPPSessionListener;

/**
 * The session model xmpp helper is used as an intermediary between the parity
 * session model and the xmpp session implementation. It handles all of the
 * events generated by the xmpp implementation and passes them on to the session
 * for further analysis.
 * 
 * @author raykroeker@gmail.com
 * @version 1.2
 */
class SessionModelXMPPHelper extends AbstractModelImplHelper {

	/** An xmpp artifact event listener. */
	private final XMPPArtifactListener xmppArtifactListener;

    /** An xmpp presence listener. */
	private final XMPPContactListener xmppContactListener;

    /** An xmpp container event listener. */
    private final XMPPContainerListener xmppContainerListener;

	/** An xmpp document event listener. */
    private final XMPPDocumentListener xmppDocumentListener;

	/** The xmpp session. */
	private final XMPPSession xmppSession;

	/** An xmpp Session listener. */
	private final XMPPSessionListener xmppSessionListener;

	/**
	 * Create a SessionModelXMPPHelper
	 */
	SessionModelXMPPHelper() {
		super();
		this.xmppSession = XMPPSessionFactory.createSession();
		this.xmppArtifactListener = new XMPPArtifactListener() {
            public void confirmReceipt(final UUID uniqueId,
                    final Long versionId, final JabberId receivedFrom) {
                handleConfirmationReceipt(uniqueId, versionId, receivedFrom);
            }
            public void handleDraftCreated(final UUID uniqueId,
                    final JabberId createdBy, final Calendar createdOn) {
                SessionModelImpl.handleArtifactDraftCreated(uniqueId,
                        createdBy, createdOn);
            }
            public void handleDraftDeleted(final UUID uniqueId,
                    final JabberId deletedBy, final Calendar deletedOn) {
                SessionModelImpl.handleArtifactDraftDeleted(uniqueId,
                        deletedBy, deletedOn);
            }
			public void teamMemberAdded(final UUID uniqueId,
                    final JabberId jabberId) {
                handleTeamMemberAdded(uniqueId, jabberId);
            }
            public void teamMemberRemoved(final UUID artifactUniqueId,
                    final JabberId jabberId) {
				handleTeamMemberRemoved(artifactUniqueId, jabberId);
			}
		};
        this.xmppContainerListener = new XMPPContainerListener() {
            public void handleArtifactPublished(final JabberId publishedBy,
                    final Calendar publishedOn, final UUID containerUniqueId,
                    final Long containerVersionId, final String containerName,
                    final Integer containerArtifactCount,
                    final Integer containerArtifactIndex,
                    final UUID artifactUniqueId, final Long artifactVersionId,
                    final String artifactName, final ArtifactType artifactType,
                    final String artifactChecksum, final byte[] artifactBytes) {
                handleContainerArtifactPublished(publishedBy, publishedOn,
                        containerUniqueId, containerVersionId, containerName,
                        containerArtifactCount, containerArtifactIndex,
                        artifactUniqueId, artifactVersionId, artifactName,
                        artifactType, artifactChecksum, artifactBytes);
            }
            public void handleArtifactSent(final JabberId sentBy,
                    final Calendar sentOn, final UUID containerUniqueId,
                    final Long containerVersionId, final String containerName,
                    final Integer containerArtifactCount,
                    final Integer containerArtifactIndex,
                    final UUID artifactUniqueId, final Long artifactVersionId,
                    final String artifactName, final ArtifactType artifactType,
                    final String artifactChecksum, final byte[] artifactBytes) {
                handleContainerArtifactSent(sentBy, sentOn, containerUniqueId,
                        containerVersionId, containerName,
                        containerArtifactCount, containerArtifactIndex,
                        artifactUniqueId, artifactVersionId, artifactName,
                        artifactType, artifactChecksum, artifactBytes);
            }
            public void handlePublished(final UUID uniqueId,
                    final Long versionId, final String name,
                    final Integer artifactCount, final JabberId publishedBy,
                    final List<JabberId> publishedTo, final Calendar publishedOn) {
                handleContainerPublished(uniqueId, versionId, name,
                        artifactCount, publishedBy, publishedTo, publishedOn);
            }
            public void handleSent(final UUID uniqueId, final Long versionId,
                    final String name, final Integer artifactCount,
                    final JabberId sentBy, final Calendar sentOn,
                    final List<JabberId> sentTo) {
                SessionModelImpl.handleContainerSent(uniqueId, versionId, name,
                        artifactCount, sentBy, sentOn, sentTo);
            }
        };
        this.xmppDocumentListener = new XMPPDocumentListener() {
            public void documentReactivated(final JabberId reactivatedBy,
                    final List<JabberId> team, final UUID uniqueId,
                    final Long versionId, final String name,
                    final byte[] content) {
                handleDocumentReactivated(reactivatedBy, team, uniqueId,
                        versionId, name, content);
            }
            public void documentReceived(final JabberId receivedFrom,
                    final UUID uniqueId, final Long versionId,
                    final String name, final byte[] content) {
                Assert.assertUnreachable("SessionModelXMPPHelper$XMPPDocumentListener#documentReceived()");
            }
        };
		this.xmppContactListener = new XMPPContactListener() {
			public void handleContactDeleted(final JabberId deletedBy,
                    final Calendar deletedOn) {
                SessionModelImpl.handleContactDeleted(deletedBy, deletedOn);
            }
			public void handleContactUpdated(final JabberId contactId,
                    final Calendar updatedOn) {
                SessionModelImpl.handleContactUpdated(contactId, updatedOn);
            }
			public void handleInvitationAccepted(final JabberId acceptedBy,
                    final Calendar acceptedOn) {
				SessionModelImpl.handleContactInvitationAccepted(acceptedBy, acceptedOn);
			}
            public void handleInvitationDeclined(final EMail invitedAs,
                    final JabberId declinedBy, final Calendar declinedOn) {
                SessionModelImpl.handleContactInvitationDeclined(invitedAs, declinedBy, declinedOn);
			}
            public void handleInvitationDeleted(final EMail invitedAs,
                    final JabberId deletedBy, final Calendar deletedOn) {
                SessionModelImpl.handleContactInvitationDeleted(invitedAs,
                        deletedBy, deletedOn);
            }
            public void handleInvitationExtended(final EMail invitedAs,
                    final JabberId invitedBy, final Calendar invitedOn) {
                SessionModelImpl.handleContactInvitationExtended(invitedAs, invitedBy, invitedOn);
			}
		};
		this.xmppSessionListener = new XMPPSessionListener() {
			public void sessionEstablished() { handleSessionEstablished(); }
			public void sessionTerminated() { handleSessionTerminated(); }
			public void sessionTerminated(final Exception x) {
				handleSessionTerminated(x);
			}
		};

		xmppSession.addListener(xmppArtifactListener);
        xmppSession.addListener(xmppContainerListener);
        xmppSession.addListener(xmppDocumentListener);
		xmppSession.addListener(xmppContactListener);
		xmppSession.addListener(xmppSessionListener);
	}

    /**
     * Add a team member. This will create the team member relationship in the
     * distributed network with a pending state.
     * 
     * @param artifactId
     *            An artifact id.
     * @param jabberId
     *            A jabber id.
     * @throws SmackException
     */
    void addTeamMember(final UUID uniqueId, final JabberId jabberId)
            throws SmackException {
        xmppSession.addTeamMember(uniqueId, jabberId);
    }

    /**
     * Send an artifact received confirmation receipt.
     * 
     * @param receivedFrom
     *            From whom the artifact was received.
     * @param uniqueId
     *            The artifact unique id.
     * @param versionId
     *            The artifact version id.
     */
    void confirmArtifactReceipt(final JabberId receivedFrom,
            final UUID uniqueId, final Long versionId)
            throws SmackException {
       xmppSession.confirmArtifactReceipt(receivedFrom, uniqueId, versionId);
    }

    /**
     * Create an artifact.
     * 
     * @param uniqueId
     *            An artifact unique id.
     */
	void createArtifact(final UUID uniqueId) throws SmackException {
		xmppSession.createArtifact(uniqueId);
	}

    /**
     * Create a draft for an artifact.
     * 
     * @param uniqueId
     *            An artifact unique id.
     */
    void createDraft(final UUID uniqueId) { xmppSession.createDraft(uniqueId); }

	/**
     * Delete an artifact.
     * 
     * @param uniqueId
     *            A unique id.
     */
    void deleteArtifact(final UUID uniqueId) {
        xmppSession.deleteArtifact(uniqueId);
    }

	/**
	 * Obtain the user for the current session.
	 * 
	 * @return The user for the current session.
	 */
	User getUser() throws SmackException { return xmppSession.readCurrentUser(); }

	/**
     * Obtain the xmpp session.
     * 
     * @return The xmpp session.
     */
    XMPPSession getXMPPSession () {
        return xmppSession;
    }

	/**
	 * Determine if the user is logged in.
	 * 
	 * @return True if the user is logged in false, otherwise.
	 */
	Boolean isLoggedIn() { return xmppSession.isLoggedIn(); }

	/**
	 * Terminate the existing session for the user.
	 * 
	 * @throws SmackException
	 */
	void logout() throws SmackException { xmppSession.logout(); }

    /**
	 * Process the remote offline queue.
	 * 
	 * @throws SmackException
	 */
	void processOfflineQueue() throws SmackException {
		xmppSession.processOfflineQueue();
	}

	/**
     * Read the logged in user's profile.
     * 
     * @return A profile.
     */
	Profile readProfile() throws SmackException { return xmppSession.readProfile(); }

	/**
     * Remove a team member from the artifact team.
     * 
     * @param uniqueId
     *            An artifact unique id.
     * @param jabberId
     *            A jabber id.
     */
    void removeTeamMember(final UUID uniqueId, final JabberId jabberId) {
        xmppSession.removeTeamMember(uniqueId, jabberId);
    }

	/**
	 * Send the log file archive to the parity server.
	 * 
	 * @param logFileArchive
	 *            The log file archive.
	 * @param The
	 *            user to send the file to.
	 * @throws SmackException
	 */
	void sendLogFileArchive(final File logFileArchive, final User user)
			throws SmackException {
		xmppSession.sendLogFileArchive(logFileArchive, user);
	}

    /**
     * Event handler for confirmation receipts.
     * 
     * @param uniqueId
     *      The document unique id.
     * @param versionId
     *      The document version id.
     * @param receivedFrom
     *      From whom the confirmation was sent.
     */
    private void handleConfirmationReceipt(final UUID uniqueId,
            final Long versionId, final JabberId receivedFrom) {
        try {
            SessionModelImpl.notifyConfirmationReceipt(
                    uniqueId, versionId, receivedFrom);
        }
        catch(final ParityException px) { unexpectedOccured(px); }
        catch(final SmackException sx) { unexpectedOccured(sx); }
        catch(final RuntimeException rx) { unexpectedOccured(rx); }
    }

	/**
     * Handle the artifact published event for the container.
     * 
     * @param containerUniqueId
     *            The container unique id.
     * @param containerVersionId
     *            The container version id.
     * @param count
     *            The artifact count.
     * @param index
     *            The artifact index.
     * @param uniqueId
     *            The artifact unique id.
     * @param versionId
     *            The artifact version id.
     * @param type
     *            The artifact type.
     * @param bytes
     *            The artifact bytes.
     */
    private void handleContainerArtifactPublished(final JabberId publishedBy,
            final Calendar publishedOn, final UUID containerUniqueId,
            final Long containerVersionId, final String containerName,
            final Integer containerArtifactCount,
            final Integer containerArtifactIndex, final UUID artifactUniqueId,
            final Long artifactVersionId, final String artifactName,
            final ArtifactType artifactType, final String artifactChecksum,
            final byte[] artifactBytes) {
        try {
            SessionModelImpl.handleContainerArtifactPublished(publishedBy,
                    publishedOn, containerUniqueId, containerVersionId,
                    containerName, containerArtifactCount,
                    containerArtifactIndex, artifactUniqueId,
                    artifactVersionId, artifactName, artifactType,
                    artifactChecksum, artifactBytes);
        }
        catch(final ParityException px) { unexpectedOccured(px); }
    }

    /**
     * Handle the artifact sent event for the container.
     * 
     * @param containerUniqueId
     *            The container unique id.
     * @param containerVersionId
     *            The container version id.
     * @param count
     *            The artifact count.
     * @param index
     *            The artifact index.
     * @param uniqueId
     *            The artifact unique id.
     * @param versionId
     *            The artifact version id.
     * @param type
     *            The artifact type.
     * @param bytes
     *            The artifact bytes.
     */
    private void handleContainerArtifactSent(final JabberId sentBy,
            final Calendar sentOn, final UUID containerUniqueId,
            final Long containerVersionId, final String containerName,
            final Integer containerArtifactCount,
            final Integer containerArtifactIndex, final UUID artifactUniqueId,
            final Long artifactVersionId, final String artifactName,
            final ArtifactType artifactType, final String artifactChecksum,
            final byte[] artifactBytes) {
        try {
            SessionModelImpl.handleContainerArtifactSent(sentBy, sentOn,
                    containerUniqueId, containerVersionId, containerName,
                    containerArtifactCount, containerArtifactIndex,
                    artifactUniqueId, artifactVersionId, artifactName,
                    artifactType, artifactChecksum, artifactBytes);
        }
        catch(final ParityException px) { unexpectedOccured(px); }
    }

    /**
     * Handle the container published event.
     * 
     * @param uniqueId
     *            The container unique id.
     * @param versionId
     *            The container version id.
     * @param name
     *            The container name.
     * @param artifactCount
     *            The container artifact count.
     * @param publishedBy
     *            The publisher.
     * @param publishedTo
     *            The publishees.
     * @param publishedOn
     *            The publish date.
     */
    private void handleContainerPublished(final UUID uniqueId,
            final Long versionId, final String name,
            final Integer artifactCount, final JabberId publishedBy,
            final List<JabberId> publishedTo, final Calendar publishedOn) {
        SessionModelImpl.handleContainerPublished(uniqueId, versionId, name,
                artifactCount, publishedBy, publishedTo, publishedOn);
    }

    /**
     * Event handler for the extension listener's document reactivated event.
     * 
     * @param reactivatedBy
     *            By whom the document was reactivated.
     * @param team
     *            The team.
     * @param uniqueId
     *            The unique id.
     * @param versionId
     *            The version id.
     * @param name
     *            The name.
     * @param content
     *            The content.
     */
    private void handleDocumentReactivated(final JabberId reactivatedBy,
            final List<JabberId> team, final UUID uniqueId,
            final Long versionId, final String name, final byte[] content) {
        try {
            SessionModelImpl.notifyDocumentReactivated(reactivatedBy, team,
                    uniqueId, versionId, name, content);
        }
        catch(final ParityException px) { unexpectedOccured(px); }
        catch(final RuntimeException rx) { unexpectedOccured(rx); }
    }

	/**
	 * Event handler for the session listener's session established event.
	 *
	 */
	private void handleSessionEstablished() {
		try { SessionModelImpl.notifySessionEstablished(); }
		catch(final RuntimeException rx) { unexpectedOccured(rx); }
	}

	/**
	 * Event handler for the session listener's session termination event.
	 * 
	 */
	private void handleSessionTerminated() {
		try { SessionModelImpl.notifySessionTerminated(); }
		catch(final RuntimeException rx) { unexpectedOccured(rx); }
	}

    /**
	 * Event handler for the sesion listener's session termination with error
	 * event.
	 * 
	 * @param x
	 *            The error.
	 */
	private void handleSessionTerminated(final Exception x) {
		try { SessionModelImpl.notifySessionTerminated(x); }
		catch(final RuntimeException rx) { unexpectedOccured(rx); }
	}

    /**
     * Handle the team member added remote event.
     * 
     * @param uniqueId
     *            An artifact unique id.
     * @param jabberId
     *            A jabber id.
     */
	private void handleTeamMemberAdded(final UUID uniqueId, final JabberId jabberId) {
		try { SessionModelImpl.handleTeamMemberAdded(uniqueId, jabberId); }
		catch(final RuntimeException rx) { unexpectedOccured(rx); }
	}

    /**
     * Handle the team member removed remote event.
     * 
     * @param uniqueId
     *            An artifact unique id.
     * @param jabberId
     *            A jabber id.
     */
	private void handleTeamMemberRemoved(final UUID uniqueId,
            final JabberId jabberId) {
		try { SessionModelImpl.handleTeamMemberRemoved(uniqueId, jabberId); }
		catch(final RuntimeException rx) { unexpectedOccured(rx); }
	}

    private void unexpectedOccured(final ParityException px) {
		// TODO  Implement rModel rollback.
		logger.fatal("[LMODEL] [SESSION] [XMPP] [HANDLE REVENT]", px);
	}

    private void unexpectedOccured(final RuntimeException rx) {
		// TODO  Implement rModel rollback.
		logger.fatal("[LMODEL] [SESSION] [XMPP] [HANDLE REVENT]", rx);
	}

    private void unexpectedOccured(final SmackException sx) {
		// TODO  Implement rModel rollback.
		logger.fatal("[LMODEL] [SESSION] [XMPP] [HANDLE REVENT]", sx);
	}
}
