/*
 * Mar 7, 2005
 */
package com.thinkparity.model.parity.model.session;

import java.util.Collection;
import java.util.Vector;

import com.thinkparity.codebase.assertion.Assert;
import com.thinkparity.model.parity.ParityException;
import com.thinkparity.model.parity.api.document.DocumentVersion;
import com.thinkparity.model.parity.api.events.PresenceEvent;
import com.thinkparity.model.parity.api.events.PresenceListener;
import com.thinkparity.model.parity.api.events.SessionListener;
import com.thinkparity.model.parity.model.AbstractModelImpl;
import com.thinkparity.model.parity.model.workspace.Workspace;
import com.thinkparity.model.smack.SmackException;
import com.thinkparity.model.xmpp.user.User;

/**
 * SessionModelImpl
 * @author raykroeker@gmail.com
 * @version 1.1
 */
class SessionModelImpl extends AbstractModelImpl {

	/**
	 * List of all of the registered parity presence listeners.
	 * @see SessionModelImpl#presenceListenersLock
	 */
	private static final Collection<PresenceListener> presenceListeners;

	/**
	 * Lock used to synchronize the collection access.
	 * @see SessionModelImpl#presenceListeners
	 */
	private static final Object presenceListenersLock;

	/**
	 * List of all of the registered parity session listeners.
	 * @see SessionModelImpl#sessionListenersLock
	 */
	private static final Collection<SessionListener> sessionListeners;

	/**
	 * Lock used to synchronize the collection access.
	 * @see SessionModelImpl#sessionListeners
	 */
	private static final Object sessionListenersLock;

	/**
	 * Helper wrapper class for xmpp calls.
	 * @see SessionModelImpl#xmppHelperLock
	 */
	private static final SessionModelXMPPHelper xmppHelper;

	/**
	 * Helper wrapper's synchronization lock.
	 * @see SessionModelImpl#xmppHelper
	 */
	private static final Object xmppHelperLock;

	static {
		// create the presence listener list & sync lock
		presenceListeners = new Vector<PresenceListener>(3);
		presenceListenersLock = new Object();
		// create the session listener list & sync lock
		sessionListeners = new Vector<SessionListener>(3);
		sessionListenersLock = new Object();
		// create the xmpp helper
		xmppHelper = new SessionModelXMPPHelper();
		xmppHelperLock = new Object();
	}

	/**
	 * Handle the event generated by xmppExtensionListenerImpl.
	 * 
	 * @param documentVersion
	 *            <code>com.thinkparity.model.parity.api.document.DocumentVersion</code>
	 */
	static void notifyDocumentReceived(final DocumentVersion documentVersion) {
		/*
		 * final DocumentModel documentModel = DocumentModel.getModel();
		 * try { documentModel.createDocument(documentVersion); }
		 * catch(ParityException px) {}
		 * 
		 */
		Assert.assertNotYetImplemented("SessionModelImpl.notifyDocumentReceived()");
	}

	/**
	 * Notify all of the registered presence listeners that a user has requested
	 * visiblity into their presence.
	 * 
	 * @param user
	 *            The requesting user.
	 */
	static void notifyPresenceRequested(final User user) {
		synchronized(SessionModelImpl.presenceListenersLock) {
			for(PresenceListener listener : SessionModelImpl.presenceListeners) {
				listener.presenceRequested(new PresenceEvent(user));
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * established.
	 *
	 */
	static void notifySessionEstablished() {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionEstablished();
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * terminated.
	 *
	 */
	static void notifySessionTerminated() {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionTerminated();
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * terminated due to an error.
	 * 
	 * @param x
	 *            The cause of the session termination.
	 */
	static void notifySessionTerminated(final Exception x) {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionTerminated(x);
			}
		}
	}

	/**
	 * Create a SessionModelImpl
	 * @deprecated
	 */
	SessionModelImpl() { this(null); }

	/**
	 * Create a SessionModelImpl
	 * @param workspace
	 */
	SessionModelImpl(final Workspace workspace) { super(workspace); }

	/**
	 * Accept a presence request from user.
	 * 
	 * @param user
	 *            The user to accept the request from.
	 * @throws ParityException
	 */
	void acceptPresence(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			try { xmppHelper.acceptPresence(user); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Add a presence listener to the session.
	 * 
	 * @param presenceListener
	 *            The presence listener to add.
	 */
	void addListener(final PresenceListener presenceListener) {
		Assert.assertNotNull("Cannot register a null presence listener.",
				presenceListener);
		synchronized(SessionModelImpl.presenceListenersLock) {
			Assert.assertTrue("Cannot re-register the same presence listener.",
					!SessionModelImpl.presenceListeners.contains(presenceListener));
			SessionModelImpl.presenceListeners.add(presenceListener);
		}
	}

	/**
	 * Add a session listener to the session.
	 * 
	 * @param sessionListener
	 *            The session listener to add.
	 */
	void addListener(final SessionListener sessionListener) {
		Assert.assertNotNull("Cannot register a null session listener.",
				sessionListener);
		Assert.assertTrue("Cannot re-register the same session listener.",
				!sessionListeners.contains(sessionListener));
		sessionListeners.add(sessionListener);
	}

	/**
	 * Add a roster entry for the user. This will send a presence request to
	 * user.
	 * 
	 * @param user
	 *            The user to add to the roster.
	 * @throws ParityException
	 */
	void addRosterEntry(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			try { xmppHelper.addRosterEntry(user); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Deny a presence request from user.
	 * 
	 * @param user
	 *            The user to deny.
	 * @throws ParityException
	 */
	void denyPresence(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("denyPresence", xmppHelper);
			try { xmppHelper.denyPresence(user); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Obtain a list of roster entries.
	 * 
	 * @return The list of roster entries.
	 * @throws ParityException
	 */
	Collection<User> getRosterEntries() throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("getRosterEntries", xmppHelper);
			try { return xmppHelper.getRosterEntries(); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Determine whether or not a user is logged in.
	 * 
	 * @return True if the user is logged in, false otherwise.
	 */
	Boolean isLoggedIn() {
		synchronized(xmppHelperLock) { return xmppHelper.isLoggedIn(); }
	}

	/**
	 * Establish a new xmpp session.
	 * 
	 * @param username
	 *            The login.
	 * @param password
	 *            The login password.
	 * @throws ParityException
	 */
	void login(final String username, final String password) throws ParityException {
		final String host = preferences.getServerHost();
		final Integer port = preferences.getServerPort();
		synchronized(xmppHelperLock) {
			try { xmppHelper.login(host, port, username, password); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Terminate the current session.
	 * @throws ParityException
	 */
	void logout() throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("logout", xmppHelper);
			try { xmppHelper.logout(); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Remove a session listener from the session.
	 * 
	 * @param sessionListener
	 */
	void removeListener(final SessionListener sessionListener) {
		Assert.assertNotNull("Cannot remove a null session listener.",
				sessionListener);
		if(sessionListeners.contains(sessionListener))
			sessionListeners.remove(sessionListener);
	}

	/**
	 * Send a document version to a user.
	 * @param user The user to send the document to.
	 * @param documentVersion The document version to send.
	 * @throws ParityException
	 */
	void send(final User user, final DocumentVersion documentVersion)
			throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("send", xmppHelper);
			try { xmppHelper.send(user, documentVersion); }
			catch(SmackException sx) { throw translate(sx); }
		}
	}

	/**
	 * Update a roster entry for the currently logged in user.
	 * 
	 * @param user
	 *            The roster entry to update.
	 * @throws ParityException
	 */
	void updateRosterEntry(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("updateRosterEntry", xmppHelper);
			xmppHelper.updateRosterEntry(user);
		}
	}

	/**
	 * Assert that the user is currently logged in.
	 * 
	 * @param message
	 *            Message to display in the assertion.
	 * @param xmppHelper
	 *            A handle to the xmpp helper in order to determine logged in
	 *            status.
	 */
	private void assertIsLoggedIn(final String message,
			final SessionModelXMPPHelper xmppHelper) {
		Assert.assertTrue(message, xmppHelper.isLoggedIn());
	}
}
