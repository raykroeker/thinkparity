/*
 * Mar 7, 2005
 */
package com.thinkparity.model.parity.model.session;

import java.text.MessageFormat;
import java.util.Collection;
import java.util.UUID;
import java.util.Vector;

import org.apache.log4j.Logger;

import com.thinkparity.codebase.StringUtil.Separator;
import com.thinkparity.codebase.assertion.Assert;

import com.thinkparity.model.log4j.ModelLoggerFactory;
import com.thinkparity.model.parity.ParityErrorTranslator;
import com.thinkparity.model.parity.ParityException;
import com.thinkparity.model.parity.api.events.KeyEvent;
import com.thinkparity.model.parity.api.events.KeyListener;
import com.thinkparity.model.parity.api.events.PresenceEvent;
import com.thinkparity.model.parity.api.events.PresenceListener;
import com.thinkparity.model.parity.api.events.SessionListener;
import com.thinkparity.model.parity.model.AbstractModelImpl;
import com.thinkparity.model.parity.model.document.Document;
import com.thinkparity.model.parity.model.document.DocumentAction;
import com.thinkparity.model.parity.model.document.DocumentActionData;
import com.thinkparity.model.parity.model.document.DocumentModel;
import com.thinkparity.model.parity.model.workspace.Workspace;
import com.thinkparity.model.smack.SmackException;
import com.thinkparity.model.xmpp.document.XMPPDocument;
import com.thinkparity.model.xmpp.user.User;

/**
 * SessionModelImpl
 * @author raykroeker@gmail.com
 * @version 1.1
 * 
 * TODO Updates\new documents are BOLD - Includes receive of history items as 
 * well as ownership request; send ownership.  This means the SEEN flag must be
 * removed once a request\request response has been processed.
 */
class SessionModelImpl extends AbstractModelImpl {

	/**
	 * Assertion used to compare the username provided with the username in
	 * the preferences.
	 */
	private static final String ASSERT_USERNAME_EQUALS_PREFS =
		"The username supplied \"{0}\" does not match the preferences \"{1}\".";

	/**
	 * List of all of the registered parity key listeners.
	 * 
	 * @see SessionModelImpl#keyListenersLock
	 */
	private static final Collection<KeyListener> keyListeners;

	/**
	 * Synchronization lock for the key listeners list.
	 * 
	 * @see SessionModelImpl#keyListeners
	 */
	private static final Object keyListenersLock;

	/**
	 * List of all of the registered parity presence listeners.
	 * 
	 * @see SessionModelImpl#presenceListenersLock
	 */
	private static final Collection<PresenceListener> presenceListeners;

	/**
	 * Lock used to synchronize the collection access.
	 * 
	 * @see SessionModelImpl#presenceListeners
	 */
	private static final Object presenceListenersLock;

	/**
	 * List of all of the registered parity session listeners.
	 * 
	 * @see SessionModelImpl#sessionListenersLock
	 */
	private static final Collection<SessionListener> sessionListeners;

	/**
	 * Lock used to synchronize the collection access.
	 * 
	 * @see SessionModelImpl#sessionListeners
	 */
	private static final Object sessionListenersLock;

	/**
	 * Handle to an apache logger for the static methods.
	 * 
	 */
	private static final Logger sLogger =
		ModelLoggerFactory.getLogger(SessionModelImpl.class);

	/**
	 * Helper wrapper class for xmpp calls.
	 * 
	 * @see SessionModelImpl#xmppHelperLock
	 */
	private static final SessionModelXMPPHelper xmppHelper;

	/**
	 * Helper wrapper's synchronization lock.
	 * 
	 * @see SessionModelImpl#xmppHelper
	 */
	private static final Object xmppHelperLock;

	static {
		// create the key listener list & sync lock
		keyListeners = new Vector<KeyListener>(3);
		keyListenersLock = new Object();
		// create the presence listener list & sync lock
		presenceListeners = new Vector<PresenceListener>(3);
		presenceListenersLock = new Object();
		// create the session listener list & sync lock
		sessionListeners = new Vector<SessionListener>(3);
		sessionListenersLock = new Object();
		// create the xmpp helper
		xmppHelper = new SessionModelXMPPHelper();
		xmppHelperLock = new Object();
	}

	/**
	 * Handle the event generated by xmppExtensionListenerImpl.  Here we create
	 * a new document based upon the document version.
	 * 
	 * @param xmppDocument
	 *            The xmpp document that has been received.
	 */
	static void notifyDocumentReceived(final XMPPDocument xmppDocument) {
		final DocumentModel documentModel = DocumentModel.getModel();
		try { documentModel.receive(xmppDocument); }
		catch(ParityException px) {
			sLogger.fatal("Could not receive document.", px);
			return;
		}
	}

	/**
	 * Handle the event generated by the xmpp extension listener. Here we pass
	 * on the event to the key listener.
	 * 
	 * @param artifactUUID
	 *            The artifact unique id.
	 * @param user
	 *            The user.
	 */
	static void notifyKeyRequestAccepted(final UUID artifactUUID,
			final User user) {
		final DocumentModel documentModel = DocumentModel.getModel();
		try { documentModel.unlock(artifactUUID); }
		catch(ParityException px) {
			sLogger.fatal("Could not accept key request.", px);
			return;
		}
		synchronized(SessionModelImpl.keyListenersLock) {
			final KeyEvent keyEvent = new KeyEvent(artifactUUID, user);
			for(KeyListener listener : SessionModelImpl.keyListeners) {
				listener.keyRequestAccepted(keyEvent);
			}
		}
	}

	/**
	 * Handle the event generated by the xmpp extension listener. Here we pass
	 * on the notification to the key listener.
	 * 
	 * @param artifactUUID
	 *            The artifact unique id.
	 * @param user
	 *            The user.
	 */
	static void notifyKeyRequestDenied(final UUID artifactUUID,
			final User user) {
		synchronized(SessionModelImpl.keyListenersLock) {
			final KeyEvent keyEvent = new KeyEvent(artifactUUID, user);
			for(KeyListener listener : SessionModelImpl.keyListeners) {
				listener.keyRequestAccepted(keyEvent);
			}
		}
	}

	/**
	 * Notify all of the registered key listeners that a user has requested the
	 * key for a given artifact.
	 * 
	 * @param user
	 *            The requesting user.
	 * @param artifactUUID
	 *            The artifact.
	 */
	static void notifyKeyRequested(final User user, final UUID artifactUUID) {
		synchronized(SessionModelImpl.keyListenersLock) {
			final KeyEvent keyEvent = new KeyEvent(artifactUUID, user);
			for(KeyListener listener : SessionModelImpl.keyListeners) {
				listener.keyRequested(keyEvent);
			}
		}
	}

	/**
	 * Notify all of the registered presence listeners that a user has requested
	 * visiblity into their presence.
	 * 
	 * @param user
	 *            The requesting user.
	 */
	static void notifyPresenceRequested(final User user) {
		synchronized(SessionModelImpl.presenceListenersLock) {
			for(PresenceListener listener : SessionModelImpl.presenceListeners) {
				listener.presenceRequested(new PresenceEvent(user));
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * established.
	 *
	 */
	static void notifySessionEstablished() {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionEstablished();
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * terminated.
	 *
	 */
	static void notifySessionTerminated() {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionTerminated();
			}
		}
	}

	/**
	 * Notify all of the registered session listeners that the session has been
	 * terminated due to an error.
	 * 
	 * @param x
	 *            The cause of the session termination.
	 */
	static void notifySessionTerminated(final Exception x) {
		synchronized(SessionModelImpl.sessionListenersLock) {
			for(SessionListener listener : SessionModelImpl.sessionListeners) {
				listener.sessionTerminated(x);
			}
		}
	}

	/**
	 * Create a SessionModelImpl
	 * @param workspace
	 */
	SessionModelImpl(final Workspace workspace) { super(workspace); }

	/**
	 * Accept a presence request from user.
	 * 
	 * @param user
	 *            The user to accept the request from.
	 * @throws ParityException
	 */
	void acceptPresence(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			try { xmppHelper.acceptPresence(user); }
			catch(SmackException sx) {
				logger.error("acceptPresence(User)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("acceptPresence(User)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Add a key listener to the session.
	 * 
	 * @param keyListener
	 *            The key listener to add.
	 */
	void addListener(final KeyListener keyListener) {
		Assert.assertNotNull("Cannot register a null key listener.", keyListener);
		synchronized(SessionModelImpl.keyListenersLock) {
			Assert.assertNotTrue(
					"Cannot re-registry the same key listener.",
					SessionModelImpl.keyListeners.contains(keyListener));
			SessionModelImpl.keyListeners.add(keyListener);
		}
	}

	/**
	 * Add a presence listener to the session.
	 * 
	 * @param presenceListener
	 *            The presence listener to add.
	 */
	void addListener(final PresenceListener presenceListener) {
		Assert.assertNotNull("Cannot register a null presence listener.",
				presenceListener);
		synchronized(SessionModelImpl.presenceListenersLock) {
			Assert.assertTrue("Cannot re-register the same presence listener.",
					!SessionModelImpl.presenceListeners.contains(presenceListener));
			SessionModelImpl.presenceListeners.add(presenceListener);
		}
	}

	/**
	 * Add a session listener to the session.
	 * 
	 * @param sessionListener
	 *            The session listener to add.
	 */
	void addListener(final SessionListener sessionListener) {
		Assert.assertNotNull("Cannot register a null session listener.",
				sessionListener);
		Assert.assertTrue("Cannot re-register the same session listener.",
				!sessionListeners.contains(sessionListener));
		sessionListeners.add(sessionListener);
	}

	/**
	 * Add a roster entry for the user. This will send a presence request to
	 * user.
	 * 
	 * @param user
	 *            The user to add to the roster.
	 * @throws ParityException
	 */
	void addRosterEntry(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			try { xmppHelper.addRosterEntry(user); }
			catch(SmackException sx) {
				logger.error("addRosterEntry(User)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("addRosterEntry(User)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Deny a presence request from user.
	 * 
	 * @param user
	 *            The user to deny.
	 * @throws ParityException
	 */
	void denyPresence(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("denyPresence", xmppHelper);
			try { xmppHelper.denyPresence(user); }
			catch(SmackException sx) {
				logger.error("denyPresence(User)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("denyPresence(User)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Obtain a list of roster entries.
	 * 
	 * @return The list of roster entries.
	 * @throws ParityException
	 */
	Collection<User> getRosterEntries() throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("getRosterEntries", xmppHelper);
			try { return xmppHelper.getRosterEntries(); }
			catch(SmackException sx) {
				logger.error("getRosterEntries()", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("getRosterEntries()", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Determine whether or not a user is logged in.
	 * 
	 * @return True if the user is logged in, false otherwise.
	 */
	Boolean isLoggedIn() {
		synchronized(xmppHelperLock) { return xmppHelper.isLoggedIn(); }
	}

	/**
	 * Establish a new xmpp session.
	 * 
	 * @param username
	 *            The login.
	 * @param password
	 *            The login password.
	 * @throws ParityException
	 */
	void login(final String username, final String password) throws ParityException {
		logger.info("login(String,String)");
		logger.debug(username);
		logger.debug(mask(password));
		final String host = preferences.getServerHost();
		final Integer port = preferences.getServerPort();
		synchronized(xmppHelperLock) {
			try {
				// check that the preferences username matches the username
				// supplied
				if(preferences.isSetUsername()) {
					Assert.assertTrue(
							formatAssertUsernameEqualsPreferences(username),
							username.equals(preferences.getUsername()));
				}
				// login
				xmppHelper.login(host, port, username, password);
				// set the username@host in the preferences
				if(!preferences.isSetUsername()) {
					preferences.setUsername(username);
				}
			}
			catch(SmackException sx) {
				logger.error("login(String,String)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("login(String,String)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Terminate the current session.
	 * @throws ParityException
	 */
	void logout() throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("logout", xmppHelper);
			try { xmppHelper.logout(); }
			catch(SmackException sx) {
				logger.error("logout()", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("logout()", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Remove a key listener from the session.
	 * 
	 * @param keyListener
	 *            The key listener to remove.
	 */
	void removeListener(final KeyListener keyListener) {
		logger.info("removeListener(KeyListener)");
		logger.debug(keyListener);
		Assert.assertNotNull("Cannot remove a null key listener.", keyListener);
		synchronized(SessionModelImpl.keyListenersLock) {
			Assert.assertTrue(
					"Cannot remove a non-registered listener.",
					SessionModelImpl.keyListeners.contains(keyListener));
			SessionModelImpl.keyListeners.remove(keyListener);
		}
	}

	/**
	 * Remove a presence listener from the session.
	 * 
	 * @param presenceListener
	 *            The presence listener to remove.
	 */
	void removeListener(final PresenceListener presenceListener) {
		logger.info("removeListener(PresenceListener)");
		logger.debug(presenceListener);
		Assert.assertNotNull("Cannot remove a null presence listener.", presenceListener);
		synchronized(SessionModelImpl.presenceListenersLock) {
			Assert.assertTrue(
					"Cannot remove a non-registered listener.",
					SessionModelImpl.presenceListeners.contains(presenceListener));
			SessionModelImpl.presenceListeners.remove(presenceListener);
		}
	}

	/**
	 * Remove a session listener from the session.
	 * 
	 * @param sessionListener
	 *            The session listener to remove.
	 */
	void removeListener(final SessionListener sessionListener) {
		logger.info("removeListener(SessionListener)");
		logger.debug(sessionListener);
		Assert.assertNotNull("Cannot remove a null session listener.", sessionListener);
		synchronized(SessionModelImpl.sessionListenersLock) {
			Assert.assertTrue(
					"Cannot remove a non-registered listener.",
					SessionModelImpl.sessionListeners.contains(sessionListener));
			SessionModelImpl.sessionListeners.remove(sessionListener);
		}
	}

	/**
	 * Send the parity log file. To be used in order to troubleshoot remote
	 * problems.
	 * 
	 * @throws ParityException
	 */
	void sendLogFileArchive() throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("sendLogFile()", xmppHelper);
			try {
				xmppHelper.sendLogFileArchive(
						workspace.getLogArchive(), preferences.getSystemUser());
			}
			catch(final SmackException sx) {
				logger.error("sendLogFile()", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(final RuntimeException rx) {
				logger.error("sendLogFile()", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Send a message to a list of parity users.
	 * 
	 * @param users
	 *            The list of parity users to send to.
	 * @param message
	 *            The message to send.
	 * @throws ParityException
	 */
	void send(final Collection<User> users, final String message)
			throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("send(Collection<User>,String)", xmppHelper);
			try { xmppHelper.send(users, message); }
			catch(SmackException sx) {
				logger.error("send(Collection<User>,String)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("send(Collection<User>,String)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Send a document to a list of parity users. The document is converted from
	 * a parity object into an xmpp document in order to send it, then each user
	 * is sent the document.
	 * 
	 * @param users
	 *            The list of parity users to send to.
	 * @param documentId
	 *            The document unique id.
	 * @throws ParityException
	 */
	void send(final Collection<User> users, final UUID documentId)
			throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("send(Collection<User>,Document)", xmppHelper);
			try {
				// create a new version (updating local content into the
				// document content metadata) then send.
				if(isFirstSend(documentId)) {
					// register the document on the server.
					SessionModelImpl.xmppHelper.sendCreate(documentId);
				}
				final DocumentModel documentModel = getDocumentModel();
				documentModel.createVersion(documentId, DocumentAction.SEND,
						createSendDocumentActionData(users));
				final Document document = documentModel.get(documentId);
				xmppHelper.send(users,
						XMPPDocument.create(document, 
								documentModel.getContent(documentId)));
			}
			catch(SmackException sx) {
				logger.error("send(Collection<User>,Document)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("send(Collection<User>,Document)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Send a creation registration to the parity server.
	 * 
	 * @param document
	 *            The document.
	 * @throws ParityException
	 */
	void sendCreate(final Document document) throws ParityException {
		logger.info("sendCreate(Document)");
		logger.debug(document);
		synchronized(SessionModelImpl.xmppHelperLock) {
			assertIsLoggedIn("sendCreate(Document)", SessionModelImpl.xmppHelper);
			try { SessionModelImpl.xmppHelper.sendCreate(document.getId()); }
			catch(SmackException sx) {
				logger.error("sendCreate(Document)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("sendCreate(Document)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Send a reqest for a document key to the parity server.
	 * 
	 * @param documentId
	 *            The document unique id.
	 * @throws ParityException
	 * @see KeyListener#keyRequested(KeyEvent)
	 */
	void sendKeyRequest(final UUID documentId) throws ParityException {
		logger.info("sendKeyRequest(UUID)");
		logger.debug(documentId);
		synchronized(SessionModelImpl.xmppHelperLock) {
			assertIsLoggedIn("sendKeyRequest(UUID)", SessionModelImpl.xmppHelper);
			try { SessionModelImpl.xmppHelper.sendKeyRequest(documentId); }
			catch(SmackException sx) {
				logger.error("sendKeyRequest(UUID)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("sendKeyRequest(UUID)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Send the response to a key request.
	 * 
	 * @param documentId
	 *            The document unique id.
	 * @param user
	 *            The user.
	 * @param keyResponse
	 *            The response.
	 */
	void sendKeyResponse(final UUID documentId, final User user,
			final KeyResponse keyResponse) throws ParityException {
		logger.info("sendKeyResponse(UUID,User,KeyResponse)");
		logger.debug(documentId);
		logger.debug(user);
		logger.debug(keyResponse);
		final DocumentModel documentModel = getDocumentModel();
		synchronized(SessionModelImpl.xmppHelperLock) {
			assertIsLoggedIn(
					"sendKeyResponse(Document,User,KeyResponse)",
					SessionModelImpl.xmppHelper);
			try {
				// if the user sends an acceptance of the key request; we
				// want to send the latest version to the requesting user
				switch(keyResponse) {
				case ACCEPT:
					send(user, documentId);
					documentModel.lock(documentId);
					break;
				case DENY:
					break;
				default: throw Assert.createUnreachable("");
				}
				SessionModelImpl.xmppHelper.sendKeyResponse(
						documentId, keyResponse, user);
			}
			catch(SmackException sx) {
				logger.error("sendKeyResponse(Document,User,KeyResponse)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("sendKeyResponse(Document,User,KeyResponse)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Subscribe to a document. The parity server is notified and will create a
	 * subscription entry for the logged in user.
	 * 
	 * @param document
	 *            The document to subscribe to.
	 * @throws ParityException
	 */
	void sendSubscribe(final Document document) throws ParityException {
		logger.info("sendSubscribe(Document)");
		logger.debug(document);
		synchronized(SessionModelImpl.xmppHelperLock) {
			assertIsLoggedIn("sendSubscribe(Document)", SessionModelImpl.xmppHelper);
			try { SessionModelImpl.xmppHelper.sendSubscribe(document.getId()); }
			catch(SmackException sx) {
				logger.error("sendSubscribe(Document)", sx);
				throw ParityErrorTranslator.translate(sx);
			}
			catch(RuntimeException rx) {
				logger.error("sendSubscribe(Document)", rx);
				throw ParityErrorTranslator.translate(rx);
			}
		}
	}

	/**
	 * Update a roster entry for the currently logged in user.
	 * 
	 * @param user
	 *            The roster entry to update.
	 * @throws ParityException
	 */
	void updateRosterEntry(final User user) throws ParityException {
		synchronized(xmppHelperLock) {
			assertIsLoggedIn("updateRosterEntry", xmppHelper);
			xmppHelper.updateRosterEntry(user);
		}
	}

	/**
	 * Assert that the user is currently logged in.
	 * 
	 * @param message
	 *            Message to display in the assertion.
	 * @param xmppHelper
	 *            A handle to the xmpp helper in order to determine logged in
	 *            status.
	 */
	private void assertIsLoggedIn(final String message,
			final SessionModelXMPPHelper xmppHelper) {
		Assert.assertTrue(message, xmppHelper.isLoggedIn());
	}

	/**
	 * Create the action data for a send action.
	 * 
	 * @param users
	 *            The users the document was sent to.
	 * @return The action data.
	 */
	private DocumentActionData createSendDocumentActionData(
			final Collection<User> users) {
		final DocumentActionData actionData = new DocumentActionData();
		final StringBuffer userList = new StringBuffer();
		for(User user : users) {
			if(0 < userList.length()) { userList.append(Separator.Comma); }
			userList.append(user.getUsername());
		}
		actionData.setDataItem("users", userList.toString());
		return actionData;
	}

	/**
	 * Create an asssertion message.
	 * 
	 * @param username
	 *            The username.
	 * @return The assertion message.
	 */
	private String formatAssertUsernameEqualsPreferences(final String username) {
		final MessageFormat f = new MessageFormat(ASSERT_USERNAME_EQUALS_PREFS);
		return f.format(new Object[] {username, preferences.getUsername()});
	}

	/**
	 * Determine whether or not this is the first time the document's been sent.
	 * 
	 * @param documentID
	 *            The document unique id.
	 * @return True if this document has not yet been sent; false otherwise.
	 * @throws ParityException
	 */
	private Boolean isFirstSend(final UUID documentId)
			throws ParityException {
		final DocumentModel documentModel = getDocumentModel();
		// HACK:  Use the server api to determine if it has been registered or not
		return 1 == documentModel.listVersions(documentId).size();
	}

	/**
	 * Mask the password for logging statements.
	 * 
	 * @param password
	 *            The password.
	 * @return The password mask.
	 */
	private String mask(final String password) { return "XXXXXXXXXX"; }

	/**
	 * Ease of use method for sending a document to a single user.
	 * 
	 * @param user
	 *            The user to send the document to.
	 * @param documentId
	 *            The document unique id.
	 * @throws ParityException
	 */
	private void send(final User user, final UUID documentId)
			throws ParityException {
		final Collection<User> users = new Vector<User>(1);
		users.add(user);
		send(users, documentId);
	}
}
