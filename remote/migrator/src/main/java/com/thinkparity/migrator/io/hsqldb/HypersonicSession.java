/*
 * Feb 9, 2006
 */
package com.thinkparity.migrator.io.hsqldb;

import java.sql.*;
import java.util.Calendar;

import org.apache.log4j.Logger;

import com.thinkparity.codebase.DateUtil;
import com.thinkparity.codebase.JVMUniqueId;
import com.thinkparity.codebase.DateUtil.DateImage;

import com.thinkparity.migrator.Library;
import com.thinkparity.migrator.LoggerFactory;
import com.thinkparity.migrator.io.md.MetaData;
import com.thinkparity.migrator.io.md.MetaDataType;
import com.thinkparity.migrator.util.JabberId;
import com.thinkparity.migrator.util.JabberIdBuilder;

/**
 * @author raykroeker@gmail.com
 * @version 1.1
 */
public class HypersonicSession {

	/**
	 * An apache logger.
	 * 
	 */
	protected final Logger logger;

	/**
	 * The sql connection.
	 * 
	 */
	private final Connection connection;

	/**
	 * The session id.
	 * 
	 */
	private final JVMUniqueId id;

	/**
	 * A prepared statement.
	 * 
	 * @see #prepareStatement(String)
	 */
	private PreparedStatement preparedStatement;

	/**
	 * A result set.
	 * 
	 */
	private ResultSet resultSet;

	/**
	 * Create a HypersonicSession.
	 * 
	 * @param connection
	 *            The sql connection.
	 */
	HypersonicSession(final Connection connection) {
		super();
		this.connection = connection;
		this.logger = LoggerFactory.getLogger(getClass());
		this.id = JVMUniqueId.nextId();
	}

	public void close() {
		assertOpen("[CLOSE]");
		try {
			close(preparedStatement, resultSet);
			connection.close();
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		HypersonicSessionManager.close(this);
	}

	public void commit() {
		assertOpen("[COMMIT]");
		try { connection.commit(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 * 
	 */
	public boolean equals(Object obj) {
		if(null != obj && obj instanceof HypersonicSession)
			return id.equals(((HypersonicSession) obj).id);
		return false;
	}

	public void execute(final String sql) {
		assertOpen("[EXECUTE]");
		debugSql(sql);
		try {
			final Statement s = connection.createStatement();
			s.execute(sql);
			commit();
		}
		catch(final SQLException sqlx) {
			rollback();
			throw new HypersonicException(sqlx);
		}
	}

	public void execute(final String[] sql) {
		assertOpen("[EXECUTE]");
		debug(sql);
		Statement statement = null;
		try {
			statement = connection.createStatement();
			for(final String s : sql) {
				statement.addBatch(s);
			}
			statement.executeBatch();
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		finally { close(statement); }
	}

	/**
	 * Executes the SQL query in the session <code>PreparedStatement</code>
	 * object and sets the <code>ResultSet</code> object generated by the
	 * query.
	 * 
	 * @see #prepareStatement(String)
	 * @see #nextResult()
	 */
	public void executeQuery() {
		assertOpen("[EXECUTE QUERY]");
		assertPreparedStatement("[EXECUTE QUERY]");
		try { resultSet = preparedStatement.executeQuery(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public int executeUpdate() {
		assertOpen("[EXECUTE UPDATE]");
		assertPreparedStatement("[EXECUTE UPDATE]");
		try { return preparedStatement.executeUpdate(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public byte[] getBytes(final String columnName) {
		assertOpen("[GET BYTES]");
		assertOpenResult("[GET BYTES]");
        debugSql(columnName);
        try { return resultSet.getBytes(columnName); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public Calendar getCalendar(final String columnName) {
		assertOpen("[GET CALENDAR]");
		assertOpenResult("[GET CALENDAR]");
        debugSql(columnName);
		try {
			final Calendar calendar = DateUtil.getInstance();
			final Timestamp timestamp = resultSet.getTimestamp(columnName, calendar);
			if(resultSet.wasNull()) { return null; }
			else {
				calendar.setTime(timestamp);
				return calendar;
			}
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	/**
	 * Obtain the session id.
	 * 
	 * @return The session id.
	 */
	public JVMUniqueId getId() { return id; }

	public Long getIdentity() {
		ResultSet resultSet = null;
		try {
			resultSet = list("CALL IDENTITY()");
			resultSet.next();
			return resultSet.getLong(1);
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		finally { close(resultSet); }
	}

    public Integer getInteger(final String columnName) {
        assertOpen("[GET INTEGER]");
        assertOpenResult("[GET INTEGER]");
        debugSql(columnName);
        try { return resultSet.getInt(columnName); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public Library.Type getLibraryTypeFromInteger(final String columnName) {
        assertOpen("[GET LIBRARY TYPE FROM INTEGER]");
        assertOpenResult("[GET LIBRARY TYPE FROM INTEGER]");
        debugSql(columnName);
        try { return Library.Type.fromId(resultSet.getInt(columnName)); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public Long getLong(final String columnName) {
		assertOpen("[GET LONG]");
		assertOpenResult("[GET LONG]");
		debugSql(columnName);
		try { return resultSet.getLong(columnName); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public MetaDataType getMetaDataTypeFromInteger(final String columnName) {
		assertOpen("[GET META DATA TYPE FROM INTEGER]");
		assertOpenResult("[GET META DATA TYPE FROM INTEGER]");
		debugSql(columnName);
		try { return MetaDataType.fromId(resultSet.getInt(columnName)); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public JabberId getQualifiedUsername(final String columnName) {
		assertOpen("[GET QUALIFIED USERNAME]");
		assertOpenResult("[GET QUALIFIED USERNAME]");
		debugSql(columnName);
		try {
			final String qualifiedUsername = resultSet.getString(columnName);
			if(resultSet.wasNull()) { return null; }
			else { return JabberIdBuilder.parseQualifiedUsername(qualifiedUsername); }
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		catch(final IllegalArgumentException iax) { throw new HypersonicException(iax); }
	}

	public String getString(final String columnName) {
		assertOpen("[GET STRING]");
		assertOpenResult("[GET STRING]");
		debugSql(columnName);
		try { return resultSet.getString(columnName); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	/**
	 * @see java.lang.Object#hashCode()
	 * 
	 */
	public int hashCode() { return id.hashCode(); }

    public boolean nextResult() {
		assertOpen("[NEXT RESULT]");
		assertOpenResult("[NEXT RESULT]");
		try { return resultSet.next(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public PreparedStatement prepareStatement(final String sql) {
		assertOpen("[PREPARE STATEMENT]");
		debugSql(sql);
		try {
			preparedStatement = connection.prepareStatement(sql);
			return preparedStatement;
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void rollback() {
		assertOpen("[ROLLBACK]");
		try { connection.commit(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setBytes(final Integer index, final byte[] bytes) {
		assertOpen("[SET BYTES]");
		assertPreparedStatement("[SET BYTES]");
		debugSql(bytes, index);
		try { preparedStatement.setBytes(index, bytes); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setCalendar(final Integer index, final Calendar calendar) {
		assertOpen("[SET CALENDAR]");
		assertPreparedStatement("[SET CALENDAR]");
		debugSql(calendar, index);
		try {
			preparedStatement.setTimestamp(index,
					new Timestamp(calendar.getTimeInMillis()), calendar);
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setInt(final Integer index, final Integer integer) {
		assertOpen("[SET INT]");
		assertPreparedStatement("[SET INT]");
		debugSql(integer, index);
		try { preparedStatement.setInt(index, integer); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setLong(final Integer index, final Long longInteger) {
		assertOpen("[SET LONG]");
		assertPreparedStatement("[SET LONG]");
		debugSql(longInteger, index);
		try { preparedStatement.setLong(index, longInteger); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setMetaDataAsString(final Integer index, final MetaData metaData) {
		assertOpen("[SET META DATA AS STRING]");
		assertPreparedStatement("[SET META DATA AS STRING]");
		debugSql(null == metaData ? null : metaData.toString(), index);
		try { preparedStatement.setString(index, metaData.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setQualifiedUsername(final Integer index,
			final JabberId jabberId) {
		assertOpen("[SET QUALIFIED USERNAME]");
		assertPreparedStatement("[SET QUALIFIED USERNAME]");
		debugSql(jabberId, index);
		try { preparedStatement.setString(index, jabberId.getQualifiedUsername()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	public void setString(final Integer index, final String string) {
		assertOpen("[SET STRING]");
		assertPreparedStatement("[SET STRING]");
		debugSql(string, index);
		try { preparedStatement.setString(index, string); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}


    public void setTypeAsInteger(final Integer index, final Library.Type type) {
        assertOpen("[SET TYPE AS INTEGER]");
        assertPreparedStatement("[SET TYPE AS INTEGER]");
        debugSql(null == type ? null : type.getId(), index);
        try { preparedStatement.setInt(index, type.getId()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setTypeAsInteger(final Integer index, final MetaDataType type) {
        assertOpen("[SET TYPE AS INTEGER]");
        assertPreparedStatement("[SET TYPE AS INTEGER]");
        debugSql(null == type ? null : type.getId(), index);
        try { preparedStatement.setInt(index, type.getId()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

	public void setTypeAsString(final Integer index, final Enum<?> type) {
		assertOpen("[SET TYPE AS STRING]");
		assertPreparedStatement("[SET TYPE AS STRING]");
		debugSql(null == type ? null : type.toString(), index);
		try { preparedStatement.setString(index, type.toString()); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

    public void setTypeAsString(final Integer index, final Library.Type type) {
        assertOpen("[SET TYPE AS STRING]");
        assertPreparedStatement("[SET TYPE AS STRING]");
        debugSql(null == type ? null : type.toString(), index);
        try { preparedStatement.setString(index, type.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }

    public void setTypeAsString(final Integer index, final MetaDataType type) {
        assertOpen("[SET TYPE AS STRING]");
        assertPreparedStatement("[SET TYPE AS STRING]");
        debugSql(null == type ? null : type.toString(), index);
        try { preparedStatement.setString(index, type.toString()); }
        catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
    }


	/**
	 * Obtain the database metadata.
	 * 
	 * @return The database metadata.
	 * @throws HypersonicException
	 */
	DatabaseMetaData getMetaData() throws HypersonicException {
		assertOpen("[GET META DATA]");
		try { return connection.getMetaData(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void assertOpen(final String assertion) {
		if(null == connection) {
			throw new HypersonicException(
                    "[RMIGRATOR] [IO] [HYPERSONIC SESSION] " + assertion + " [CONNECTION IS NULL]");
		}
	}

	private void assertOpenResult(final String assertion) {
		if(null == resultSet)
			throw new HypersonicException(
                    "[RMIGRATOR] [IO] [HYPERSONIC SESSION] " + assertion + " [RESULT IS NULL]");
	}

	private void assertPreparedStatement(final String assertion) {
		if(null == preparedStatement)
			throw new HypersonicException(
                    "[RMIGRATOR] [IO] [HYPERSONIC SESSION] " + assertion + " [STATEMENT IS NULL]");
	}

	private void close(final ResultSet resultSet) {
		try { if(null != resultSet) resultSet.close(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void close(final Statement statement) {
		try { if(null != statement) statement.close(); }
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
	}

	private void close(final Statement statement, final ResultSet resultSet) {
		close(statement);
		close(resultSet);
	}

	private void debug(final String[] sql) {
		if(null != sql) {
			int index = 0;
			for(final String s : sql) { debugSql(s, index++); }
		}
		else { debugSql((String) null, null); }
	}

	private void debugSql(final byte[] bytes, final Integer sqlIndex) {
		debugSql(null == bytes ? null : bytes.length, sqlIndex);
	}

	private void debugSql(final Calendar calendar, final Integer sqlIndex) {
		debugSql(null == calendar ? null : DateUtil.format(calendar, DateImage.ISO), sqlIndex);
	}

	private void debugSql(final Integer integer, final Integer sqlIndex) {
		debugSql(null == integer ? null : integer.toString(), sqlIndex);
	}

	private void debugSql(final JabberId jabberId, final Integer sqlIndex) {
		debugSql(null == jabberId ? null : jabberId.toString(), sqlIndex);
	}

	private void debugSql(final Long longInteger, final Integer sqlIndex) {
		debugSql(null == longInteger ? null : longInteger.toString(), sqlIndex);
	}

	private void debugSql(final String sql) {
		debugSql(sql, null);
	}

	private void debugSql(final String sql, final Integer sqlIndex) {
		final StringBuffer message = new StringBuffer("[RMIGRATOR] [IO] [HYPERSONIC SESSION] [SQL] ");
		if(null != sqlIndex) {
			message.append("[")
				.append(sqlIndex)
				.append("] ");
		}
		logger.debug(message.append(sql));
	}

	private ResultSet list(final String sql) {
		assertOpen("[LIST]");
		debugSql(sql);
		Statement statement = null;
		try {
			statement = connection.createStatement();
			return statement.executeQuery(sql);
		}
		catch(final SQLException sqlx) { throw new HypersonicException(sqlx); }
		finally { close(statement); }
	}
}
